/*
MX Platform API

The MX Platform API is a powerful, fully-featured API designed to make aggregating and enhancing financial data easy and reliable. It can seamlessly connect your app or website to tens of thousands of financial institutions.  Just getting started? See our [use case guides](/use-cases/). 

API version: 20111101
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mxplatformgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// MerchantsAPIService MerchantsAPI service
type MerchantsAPIService service

type ApiListMerchantsRequest struct {
	ctx context.Context
	ApiService *MerchantsAPIService
	name *string
	page *int32
	recordsPerPage *int32
}

// This will list only merchants in which the appended string appears.
func (r ApiListMerchantsRequest) Name(name string) ApiListMerchantsRequest {
	r.name = &name
	return r
}

// Results are paginated. Specify current page.
func (r ApiListMerchantsRequest) Page(page int32) ApiListMerchantsRequest {
	r.page = &page
	return r
}

// This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
func (r ApiListMerchantsRequest) RecordsPerPage(recordsPerPage int32) ApiListMerchantsRequest {
	r.recordsPerPage = &recordsPerPage
	return r
}

func (r ApiListMerchantsRequest) Execute() (*MerchantsResponseBody, *http.Response, error) {
	return r.ApiService.ListMerchantsExecute(r)
}

/*
ListMerchants List merchants

This endpoint returns a paginated list of all the merchants in the MX system.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListMerchantsRequest
*/
func (a *MerchantsAPIService) ListMerchants(ctx context.Context) ApiListMerchantsRequest {
	return ApiListMerchantsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantsResponseBody
func (a *MerchantsAPIService) ListMerchantsExecute(r ApiListMerchantsRequest) (*MerchantsResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantsResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantsAPIService.ListMerchants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchants"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.recordsPerPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "records_per_page", r.recordsPerPage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.mx.api.v1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadMerchantRequest struct {
	ctx context.Context
	ApiService *MerchantsAPIService
	merchantGuid string
}

func (r ApiReadMerchantRequest) Execute() (*MerchantResponseBody, *http.Response, error) {
	return r.ApiService.ReadMerchantExecute(r)
}

/*
ReadMerchant Read merchant

Returns information about a particular merchant, such as a logo, name, and website.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param merchantGuid The unique id for a `merchant`.
 @return ApiReadMerchantRequest
*/
func (a *MerchantsAPIService) ReadMerchant(ctx context.Context, merchantGuid string) ApiReadMerchantRequest {
	return ApiReadMerchantRequest{
		ApiService: a,
		ctx: ctx,
		merchantGuid: merchantGuid,
	}
}

// Execute executes the request
//  @return MerchantResponseBody
func (a *MerchantsAPIService) ReadMerchantExecute(r ApiReadMerchantRequest) (*MerchantResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantsAPIService.ReadMerchant")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchants/{merchant_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"merchant_guid"+"}", url.PathEscape(parameterValueToString(r.merchantGuid, "merchantGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.mx.api.v1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadMerchantLocationRequest struct {
	ctx context.Context
	ApiService *MerchantsAPIService
	merchantLocationGuid string
}

func (r ApiReadMerchantLocationRequest) Execute() (*MerchantLocationResponseBody, *http.Response, error) {
	return r.ApiService.ReadMerchantLocationExecute(r)
}

/*
ReadMerchantLocation Read merchant location

This endpoint returns the specified `merchant_location` resource. The `merchant_location_guid` can be found on `transaction` objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param merchantLocationGuid The unique id for a `merchant_location`.
 @return ApiReadMerchantLocationRequest
*/
func (a *MerchantsAPIService) ReadMerchantLocation(ctx context.Context, merchantLocationGuid string) ApiReadMerchantLocationRequest {
	return ApiReadMerchantLocationRequest{
		ApiService: a,
		ctx: ctx,
		merchantLocationGuid: merchantLocationGuid,
	}
}

// Execute executes the request
//  @return MerchantLocationResponseBody
func (a *MerchantsAPIService) ReadMerchantLocationExecute(r ApiReadMerchantLocationRequest) (*MerchantLocationResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantLocationResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MerchantsAPIService.ReadMerchantLocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant_locations/{merchant_location_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"merchant_location_guid"+"}", url.PathEscape(parameterValueToString(r.merchantLocationGuid, "merchantLocationGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.mx.api.v1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
