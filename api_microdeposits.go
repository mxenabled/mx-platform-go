/*
MX Platform API

The MX Platform API is a powerful, fully-featured API designed to make aggregating and enhancing financial data easy and reliable. It can seamlessly connect your app or website to tens of thousands of financial institutions.  Just getting started? See our [use case guides](/use-cases/). 

API version: 20111101
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mxplatformgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// MicrodepositsAPIService MicrodepositsAPI service
type MicrodepositsAPIService service

type ApiCreateMicrodepositRequest struct {
	ctx context.Context
	ApiService *MicrodepositsAPIService
	userGuid string
	microdepositRequestBody *MicrodepositRequestBody
}

func (r ApiCreateMicrodepositRequest) MicrodepositRequestBody(microdepositRequestBody MicrodepositRequestBody) ApiCreateMicrodepositRequest {
	r.microdepositRequestBody = &microdepositRequestBody
	return r
}

func (r ApiCreateMicrodepositRequest) Execute() (*MicrodepositResponseBody, *http.Response, error) {
	return r.ApiService.CreateMicrodepositExecute(r)
}

/*
CreateMicrodeposit Create or pre-initiate a microdeposit

Use this endpoint to create or pre-initiate a microdeposit. The response will include the new microdeposit record with a status of `INITIATED` or `PREINITIATED` respectively.

To pre-initiate a microdeposit, you only need to set `email` (string), `first_name` (string), and `last_name` (string) in the request body. 

Pre-initiating a microdeposit allows you to pass the end user's first name, last name, and email if this data has already been collected. If the end user selects an institution which requires the microdeposit flow, the pre-initiated `micro_deposit` will be used and the Connect Widget step that normally requests this info from the end user will be skipped. However, if the end user selects an institution which supports IAV, the pre-initiated `micro_deposit` will be deleted and IAV will be used instead. When requesting a Connect Widget URL after pre-initiating, make sure to set the `current_microdeposit_guid` to the resulting microdeposit's `guid` and set the `mode` to `verification`. If you use this enhanced flow, a `micro_deposit` should be pre-initiated for all connect sessions in verification mode. After pre-initiating a microdeposit, pass the GUID to the config as `current_microdeposit_guid` and set the `mode` to `verification` when requesting a Connect URL.  Pre-initiating a microdeposit is optional. If you choose to implement this flow, it should be used for all Connect Widget sessions in verification mode.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiCreateMicrodepositRequest
*/
func (a *MicrodepositsAPIService) CreateMicrodeposit(ctx context.Context, userGuid string) ApiCreateMicrodepositRequest {
	return ApiCreateMicrodepositRequest{
		ApiService: a,
		ctx: ctx,
		userGuid: userGuid,
	}
}

// Execute executes the request
//  @return MicrodepositResponseBody
func (a *MicrodepositsAPIService) CreateMicrodepositExecute(r ApiCreateMicrodepositRequest) (*MicrodepositResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MicrodepositResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MicrodepositsAPIService.CreateMicrodeposit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/micro_deposits"
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.microdepositRequestBody == nil {
		return localVarReturnValue, nil, reportError("microdepositRequestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microdepositRequestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteMicrodepositRequest struct {
	ctx context.Context
	ApiService *MicrodepositsAPIService
	microDepositGuid string
	userGuid string
}

func (r ApiDeleteMicrodepositRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteMicrodepositExecute(r)
}

/*
DeleteMicrodeposit Delete a microdeposit

Use this endpoint to delete the specified microdeposit.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param microDepositGuid The unique identifier for the microdeposit. Defined by MX.
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiDeleteMicrodepositRequest
*/
func (a *MicrodepositsAPIService) DeleteMicrodeposit(ctx context.Context, microDepositGuid string, userGuid string) ApiDeleteMicrodepositRequest {
	return ApiDeleteMicrodepositRequest{
		ApiService: a,
		ctx: ctx,
		microDepositGuid: microDepositGuid,
		userGuid: userGuid,
	}
}

// Execute executes the request
func (a *MicrodepositsAPIService) DeleteMicrodepositExecute(r ApiDeleteMicrodepositRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MicrodepositsAPIService.DeleteMicrodeposit")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/micro_deposits/{micro_deposit_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"micro_deposit_guid"+"}", url.PathEscape(parameterValueToString(r.microDepositGuid, "microDepositGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListUserMicrodepositsRequest struct {
	ctx context.Context
	ApiService *MicrodepositsAPIService
	userGuid string
}

func (r ApiListUserMicrodepositsRequest) Execute() (*MicrodepositsResponseBody, *http.Response, error) {
	return r.ApiService.ListUserMicrodepositsExecute(r)
}

/*
ListUserMicrodeposits List all microdeposits for a user

Use this endpoint to read the attributes of a specific microdeposit according to its unique GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiListUserMicrodepositsRequest
*/
func (a *MicrodepositsAPIService) ListUserMicrodeposits(ctx context.Context, userGuid string) ApiListUserMicrodepositsRequest {
	return ApiListUserMicrodepositsRequest{
		ApiService: a,
		ctx: ctx,
		userGuid: userGuid,
	}
}

// Execute executes the request
//  @return MicrodepositsResponseBody
func (a *MicrodepositsAPIService) ListUserMicrodepositsExecute(r ApiListUserMicrodepositsRequest) (*MicrodepositsResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MicrodepositsResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MicrodepositsAPIService.ListUserMicrodeposits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/micro_deposits"
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUserVerificationsRequest struct {
	ctx context.Context
	ApiService *MicrodepositsAPIService
	userGuid string
}

func (r ApiListUserVerificationsRequest) Execute() (*MicrodepositResponseBody, *http.Response, error) {
	return r.ApiService.ListUserVerificationsExecute(r)
}

/*
ListUserVerifications List all verifications for a user

This endpoint returns a list of the account verifications associated with the user, as well as the status of those verifications.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiListUserVerificationsRequest
*/
func (a *MicrodepositsAPIService) ListUserVerifications(ctx context.Context, userGuid string) ApiListUserVerificationsRequest {
	return ApiListUserVerificationsRequest{
		ApiService: a,
		ctx: ctx,
		userGuid: userGuid,
	}
}

// Execute executes the request
//  @return MicrodepositResponseBody
func (a *MicrodepositsAPIService) ListUserVerificationsExecute(r ApiListUserVerificationsRequest) (*MicrodepositResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MicrodepositResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MicrodepositsAPIService.ListUserVerifications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/account_verifications"
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadUserMicrodepositRequest struct {
	ctx context.Context
	ApiService *MicrodepositsAPIService
	microDepositGuid string
	userGuid string
}

func (r ApiReadUserMicrodepositRequest) Execute() (*MicrodepositResponseBody, *http.Response, error) {
	return r.ApiService.ReadUserMicrodepositExecute(r)
}

/*
ReadUserMicrodeposit Read a microdeposit for a user

Use this endpoint to read the attributes of a specific microdeposit according to its unique GUID. <br></br> Webhooks for microdeposit status changes are triggered when a status changes. The actual status of the microdeposit guid updates every minute. You may force a status update by calling the read microdeposit endpoint.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param microDepositGuid The unique identifier for the microdeposit. Defined by MX.
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiReadUserMicrodepositRequest
*/
func (a *MicrodepositsAPIService) ReadUserMicrodeposit(ctx context.Context, microDepositGuid string, userGuid string) ApiReadUserMicrodepositRequest {
	return ApiReadUserMicrodepositRequest{
		ApiService: a,
		ctx: ctx,
		microDepositGuid: microDepositGuid,
		userGuid: userGuid,
	}
}

// Execute executes the request
//  @return MicrodepositResponseBody
func (a *MicrodepositsAPIService) ReadUserMicrodepositExecute(r ApiReadUserMicrodepositRequest) (*MicrodepositResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MicrodepositResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MicrodepositsAPIService.ReadUserMicrodeposit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/micro_deposits/{micro_deposit_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"micro_deposit_guid"+"}", url.PathEscape(parameterValueToString(r.microDepositGuid, "microDepositGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyMicrodepositRequest struct {
	ctx context.Context
	ApiService *MicrodepositsAPIService
	microDepositGuid string
	microdepositVerifyRequestBody *MicrodepositVerifyRequestBody
}

func (r ApiVerifyMicrodepositRequest) MicrodepositVerifyRequestBody(microdepositVerifyRequestBody MicrodepositVerifyRequestBody) ApiVerifyMicrodepositRequest {
	r.microdepositVerifyRequestBody = &microdepositVerifyRequestBody
	return r
}

func (r ApiVerifyMicrodepositRequest) Execute() (*MicrodepositResponseBody, *http.Response, error) {
	return r.ApiService.VerifyMicrodepositExecute(r)
}

/*
VerifyMicrodeposit Verify a Microdeposit

Use this endpoint to verify the amounts deposited into the account during a microdeposit verification. The verification has not successfully completed until the `status` is `VERIFIED`. Poll the `/users/{user_guid}/micro_deposits/{micro_deposit_guid}` (read microdeposit) endpoint until you see this status or an error state.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param microDepositGuid The unique identifier for the microdeposit. Defined by MX.
 @return ApiVerifyMicrodepositRequest
*/
func (a *MicrodepositsAPIService) VerifyMicrodeposit(ctx context.Context, microDepositGuid string) ApiVerifyMicrodepositRequest {
	return ApiVerifyMicrodepositRequest{
		ApiService: a,
		ctx: ctx,
		microDepositGuid: microDepositGuid,
	}
}

// Execute executes the request
//  @return MicrodepositResponseBody
func (a *MicrodepositsAPIService) VerifyMicrodepositExecute(r ApiVerifyMicrodepositRequest) (*MicrodepositResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MicrodepositResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MicrodepositsAPIService.VerifyMicrodeposit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/micro_deposits/{micro_deposit_guid}/verify"
	localVarPath = strings.Replace(localVarPath, "{"+"micro_deposit_guid"+"}", url.PathEscape(parameterValueToString(r.microDepositGuid, "microDepositGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.microdepositVerifyRequestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
