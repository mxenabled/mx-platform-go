/*
MX Platform API

The MX Platform API is a powerful, fully-featured API designed to make aggregating and enhancing financial data easy and reliable. It can seamlessly connect your app or website to tens of thousands of financial institutions.  Just getting started? See our [use case guides](/use-cases/). 

API version: 20111101
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mxplatformgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// GoalsAPIService GoalsAPI service
type GoalsAPIService service

type ApiCreateGoalRequest struct {
	ctx context.Context
	ApiService *GoalsAPIService
	userGuid string
	goalRequestBody *GoalRequestBody
}

func (r ApiCreateGoalRequest) GoalRequestBody(goalRequestBody GoalRequestBody) ApiCreateGoalRequest {
	r.goalRequestBody = &goalRequestBody
	return r
}

func (r ApiCreateGoalRequest) Execute() (*GoalResponseBody, *http.Response, error) {
	return r.ApiService.CreateGoalExecute(r)
}

/*
CreateGoal Create a goal

Create a goal. This endpoint accepts the optional `MX-Skip-Webhook` header and `skip_webhook` parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiCreateGoalRequest
*/
func (a *GoalsAPIService) CreateGoal(ctx context.Context, userGuid string) ApiCreateGoalRequest {
	return ApiCreateGoalRequest{
		ApiService: a,
		ctx: ctx,
		userGuid: userGuid,
	}
}

// Execute executes the request
//  @return GoalResponseBody
func (a *GoalsAPIService) CreateGoalExecute(r ApiCreateGoalRequest) (*GoalResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GoalResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GoalsAPIService.CreateGoal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/goals"
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.goalRequestBody == nil {
		return localVarReturnValue, nil, reportError("goalRequestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.mx.api.v1+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.goalRequestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteGoalRequest struct {
	ctx context.Context
	ApiService *GoalsAPIService
	goalGuid string
	userGuid string
	accept *string
}

// Specifies the media type expected in the response.
func (r ApiDeleteGoalRequest) Accept(accept string) ApiDeleteGoalRequest {
	r.accept = &accept
	return r
}

func (r ApiDeleteGoalRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteGoalExecute(r)
}

/*
DeleteGoal Delete a goal

Delete a goal.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param goalGuid The unique identifier for a goal. Defined by MX.
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiDeleteGoalRequest
*/
func (a *GoalsAPIService) DeleteGoal(ctx context.Context, goalGuid string, userGuid string) ApiDeleteGoalRequest {
	return ApiDeleteGoalRequest{
		ApiService: a,
		ctx: ctx,
		goalGuid: goalGuid,
		userGuid: userGuid,
	}
}

// Execute executes the request
func (a *GoalsAPIService) DeleteGoalExecute(r ApiDeleteGoalRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GoalsAPIService.DeleteGoal")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/goals/{goal_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"goal_guid"+"}", url.PathEscape(parameterValueToString(r.goalGuid, "goalGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accept == nil {
		return nil, reportError("accept is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListGoalsRequest struct {
	ctx context.Context
	ApiService *GoalsAPIService
	accept *string
	userGuid string
	page *int32
	recordsPerPage *int32
}

// Specifies the media type expected in the response.
func (r ApiListGoalsRequest) Accept(accept string) ApiListGoalsRequest {
	r.accept = &accept
	return r
}

// Results are paginated. Specify current page.
func (r ApiListGoalsRequest) Page(page int32) ApiListGoalsRequest {
	r.page = &page
	return r
}

// This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
func (r ApiListGoalsRequest) RecordsPerPage(recordsPerPage int32) ApiListGoalsRequest {
	r.recordsPerPage = &recordsPerPage
	return r
}

func (r ApiListGoalsRequest) Execute() (*GoalsResponseBody, *http.Response, error) {
	return r.ApiService.ListGoalsExecute(r)
}

/*
ListGoals List goals

List all goals a user can set.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiListGoalsRequest
*/
func (a *GoalsAPIService) ListGoals(ctx context.Context, userGuid string) ApiListGoalsRequest {
	return ApiListGoalsRequest{
		ApiService: a,
		ctx: ctx,
		userGuid: userGuid,
	}
}

// Execute executes the request
//  @return GoalsResponseBody
func (a *GoalsAPIService) ListGoalsExecute(r ApiListGoalsRequest) (*GoalsResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GoalsResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GoalsAPIService.ListGoals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/goals"
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accept == nil {
		return localVarReturnValue, nil, reportError("accept is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.recordsPerPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "records_per_page", r.recordsPerPage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.mx.api.v1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadGoalRequest struct {
	ctx context.Context
	ApiService *GoalsAPIService
	goalGuid string
	userGuid string
}

func (r ApiReadGoalRequest) Execute() (*GoalResponseBody, *http.Response, error) {
	return r.ApiService.ReadGoalExecute(r)
}

/*
ReadGoal Read a goal

Read a specific goal.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param goalGuid The unique identifier for a goal. Defined by MX.
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiReadGoalRequest
*/
func (a *GoalsAPIService) ReadGoal(ctx context.Context, goalGuid string, userGuid string) ApiReadGoalRequest {
	return ApiReadGoalRequest{
		ApiService: a,
		ctx: ctx,
		goalGuid: goalGuid,
		userGuid: userGuid,
	}
}

// Execute executes the request
//  @return GoalResponseBody
func (a *GoalsAPIService) ReadGoalExecute(r ApiReadGoalRequest) (*GoalResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GoalResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GoalsAPIService.ReadGoal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/goals/{goal_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"goal_guid"+"}", url.PathEscape(parameterValueToString(r.goalGuid, "goalGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositionGoalsRequest struct {
	ctx context.Context
	ApiService *GoalsAPIService
	userGuid string
	repositionRequestBody *RepositionRequestBody
}

func (r ApiRepositionGoalsRequest) RepositionRequestBody(repositionRequestBody RepositionRequestBody) ApiRepositionGoalsRequest {
	r.repositionRequestBody = &repositionRequestBody
	return r
}

func (r ApiRepositionGoalsRequest) Execute() (*RepositionResponseBody, *http.Response, error) {
	return r.ApiService.RepositionGoalsExecute(r)
}

/*
RepositionGoals Reposition goals

This endpoint repositions goal priority levels. If one goal is set to a lower priority, then any other goals need to be adjusted accordingly.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiRepositionGoalsRequest
*/
func (a *GoalsAPIService) RepositionGoals(ctx context.Context, userGuid string) ApiRepositionGoalsRequest {
	return ApiRepositionGoalsRequest{
		ApiService: a,
		ctx: ctx,
		userGuid: userGuid,
	}
}

// Execute executes the request
//  @return RepositionResponseBody
func (a *GoalsAPIService) RepositionGoalsExecute(r ApiRepositionGoalsRequest) (*RepositionResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RepositionResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GoalsAPIService.RepositionGoals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/goals/reposition"
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.repositionRequestBody == nil {
		return localVarReturnValue, nil, reportError("repositionRequestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.mx.api.v1+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.repositionRequestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGoalRequest struct {
	ctx context.Context
	ApiService *GoalsAPIService
	goalGuid string
	userGuid string
	updateGoalRequestBody *UpdateGoalRequestBody
}

func (r ApiUpdateGoalRequest) UpdateGoalRequestBody(updateGoalRequestBody UpdateGoalRequestBody) ApiUpdateGoalRequest {
	r.updateGoalRequestBody = &updateGoalRequestBody
	return r
}

func (r ApiUpdateGoalRequest) Execute() (*GoalResponseBody, *http.Response, error) {
	return r.ApiService.UpdateGoalExecute(r)
}

/*
UpdateGoal Update a goal

This endpoint updates a specific goal.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param goalGuid The unique identifier for a goal. Defined by MX.
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiUpdateGoalRequest
*/
func (a *GoalsAPIService) UpdateGoal(ctx context.Context, goalGuid string, userGuid string) ApiUpdateGoalRequest {
	return ApiUpdateGoalRequest{
		ApiService: a,
		ctx: ctx,
		goalGuid: goalGuid,
		userGuid: userGuid,
	}
}

// Execute executes the request
//  @return GoalResponseBody
func (a *GoalsAPIService) UpdateGoalExecute(r ApiUpdateGoalRequest) (*GoalResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GoalResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GoalsAPIService.UpdateGoal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/goals/{goal_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"goal_guid"+"}", url.PathEscape(parameterValueToString(r.goalGuid, "goalGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateGoalRequestBody == nil {
		return localVarReturnValue, nil, reportError("updateGoalRequestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateGoalRequestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
