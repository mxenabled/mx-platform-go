/*
MX Platform API

The MX Platform API is a powerful, fully-featured API designed to make aggregating and enhancing financial data easy and reliable. It can seamlessly connect your app or website to tens of thousands of financial institutions.  Just getting started? See our [use case guides](/use-cases/). 

API version: 20111101
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mxplatformgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// TransactionsAPIService TransactionsAPI service
type TransactionsAPIService service

type ApiCreateManualTransactionRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	userGuid string
	accountGuid string
	transactionCreateRequestBody *TransactionCreateRequestBody
}

func (r ApiCreateManualTransactionRequest) TransactionCreateRequestBody(transactionCreateRequestBody TransactionCreateRequestBody) ApiCreateManualTransactionRequest {
	r.transactionCreateRequestBody = &transactionCreateRequestBody
	return r
}

func (r ApiCreateManualTransactionRequest) Execute() (*TransactionCreateResponseBody, *http.Response, error) {
	return r.ApiService.CreateManualTransactionExecute(r)
}

/*
CreateManualTransaction Create manual transaction

This endpoint can only be used to create manual transactions that are under a manual account. This endpoint accepts the optional MX-Skip-Webhook header and skip_webhook parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @param accountGuid The unique id for an `account`.
 @return ApiCreateManualTransactionRequest
*/
func (a *TransactionsAPIService) CreateManualTransaction(ctx context.Context, userGuid string, accountGuid string) ApiCreateManualTransactionRequest {
	return ApiCreateManualTransactionRequest{
		ApiService: a,
		ctx: ctx,
		userGuid: userGuid,
		accountGuid: accountGuid,
	}
}

// Execute executes the request
//  @return TransactionCreateResponseBody
func (a *TransactionsAPIService) CreateManualTransactionExecute(r ApiCreateManualTransactionRequest) (*TransactionCreateResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionCreateResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.CreateManualTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/accounts/{account_guid}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"account_guid"+"}", url.PathEscape(parameterValueToString(r.accountGuid, "accountGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transactionCreateRequestBody == nil {
		return localVarReturnValue, nil, reportError("transactionCreateRequestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.mx.api.v1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transactionCreateRequestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSplitTransactionsRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	transactionGuid string
	userGuid string
	splitTransactionRequestBody *SplitTransactionRequestBody
}

func (r ApiCreateSplitTransactionsRequest) SplitTransactionRequestBody(splitTransactionRequestBody SplitTransactionRequestBody) ApiCreateSplitTransactionsRequest {
	r.splitTransactionRequestBody = &splitTransactionRequestBody
	return r
}

func (r ApiCreateSplitTransactionsRequest) Execute() (*SplitTransactionsResponseBody, *http.Response, error) {
	return r.ApiService.CreateSplitTransactionsExecute(r)
}

/*
CreateSplitTransactions Create split transactions

This endpoint creates two or more child transactions that are branched from a previous transaction. This endpoint allows you to link multiple categories, descriptions, and amounts to a parent transaction.  When a split transaction is created, the parent transaction's `has_been_split` field will automatically be updated to true and the child transactions' `parent_guid` will have the transaction guid of the parent. The total amount of the child transactions must equal the amount of the parent transaction. Once a transaction has been split it can't be split again.    In order to re-split a transaction, it must first be un-split. This can be done by calling the Delete Split Transactions endpoint. Calling this endpoint will delete the existing child transactions and update the parent transaction's `has_been_split` field to false. You can then re-split the parent transaction by calling Create Split Transaction again.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionGuid The unique id for a `transaction`.
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiCreateSplitTransactionsRequest
*/
func (a *TransactionsAPIService) CreateSplitTransactions(ctx context.Context, transactionGuid string, userGuid string) ApiCreateSplitTransactionsRequest {
	return ApiCreateSplitTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		transactionGuid: transactionGuid,
		userGuid: userGuid,
	}
}

// Execute executes the request
//  @return SplitTransactionsResponseBody
func (a *TransactionsAPIService) CreateSplitTransactionsExecute(r ApiCreateSplitTransactionsRequest) (*SplitTransactionsResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SplitTransactionsResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.CreateSplitTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/transactions/{transaction_guid}/split"
	localVarPath = strings.Replace(localVarPath, "{"+"transaction_guid"+"}", url.PathEscape(parameterValueToString(r.transactionGuid, "transactionGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.mx.api.v1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.splitTransactionRequestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteManualTransactionsRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	userGuid string
	transactionGuid string
}

func (r ApiDeleteManualTransactionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteManualTransactionsExecute(r)
}

/*
DeleteManualTransactions Delete manual transactions

Delete a manual transaction. In the path, use the manual transaction guid as the `transaction_guid`, such as `MAN-810828b0-5210-4878-9bd3-f4ce514f90c4`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @param transactionGuid The unique id for a `transaction`.
 @return ApiDeleteManualTransactionsRequest
*/
func (a *TransactionsAPIService) DeleteManualTransactions(ctx context.Context, userGuid string, transactionGuid string) ApiDeleteManualTransactionsRequest {
	return ApiDeleteManualTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		userGuid: userGuid,
		transactionGuid: transactionGuid,
	}
}

// Execute executes the request
func (a *TransactionsAPIService) DeleteManualTransactionsExecute(r ApiDeleteManualTransactionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.DeleteManualTransactions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/transactions/{transaction_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transaction_guid"+"}", url.PathEscape(parameterValueToString(r.transactionGuid, "transactionGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSplitTransactionsRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	transactionGuid string
	userGuid string
}

func (r ApiDeleteSplitTransactionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSplitTransactionsExecute(r)
}

/*
DeleteSplitTransactions Delete split transactions

This endpoint deletes all split transactions linked to a parent transaction, but it leaves the parent transaction active. This request will also update the parent transaction's has_been_split field to false. This endpoint accepts the optional MX-Skip-Webhook header.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionGuid The unique id for a `transaction`.
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiDeleteSplitTransactionsRequest
*/
func (a *TransactionsAPIService) DeleteSplitTransactions(ctx context.Context, transactionGuid string, userGuid string) ApiDeleteSplitTransactionsRequest {
	return ApiDeleteSplitTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		transactionGuid: transactionGuid,
		userGuid: userGuid,
	}
}

// Execute executes the request
func (a *TransactionsAPIService) DeleteSplitTransactionsExecute(r ApiDeleteSplitTransactionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.DeleteSplitTransactions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/transactions/{transaction_guid}/split"
	localVarPath = strings.Replace(localVarPath, "{"+"transaction_guid"+"}", url.PathEscape(parameterValueToString(r.transactionGuid, "transactionGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTransactionRuleRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	transactionRuleGuid string
	userGuid string
}

func (r ApiDeleteTransactionRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTransactionRuleExecute(r)
}

/*
DeleteTransactionRule Delete transaction rule

Use this endpoint to permanently delete a transaction rule based on its unique GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionRuleGuid The unique id for a `transaction_rule`.
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiDeleteTransactionRuleRequest
*/
func (a *TransactionsAPIService) DeleteTransactionRule(ctx context.Context, transactionRuleGuid string, userGuid string) ApiDeleteTransactionRuleRequest {
	return ApiDeleteTransactionRuleRequest{
		ApiService: a,
		ctx: ctx,
		transactionRuleGuid: transactionRuleGuid,
		userGuid: userGuid,
	}
}

// Execute executes the request
func (a *TransactionsAPIService) DeleteTransactionRuleExecute(r ApiDeleteTransactionRuleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.DeleteTransactionRule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/transaction_rules/{transaction_rule_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"transaction_rule_guid"+"}", url.PathEscape(parameterValueToString(r.transactionRuleGuid, "transactionRuleGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnhanceTransactionsRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	enhanceTransactionsRequestBody *EnhanceTransactionsRequestBody
}

// Transaction object to be enhanced
func (r ApiEnhanceTransactionsRequest) EnhanceTransactionsRequestBody(enhanceTransactionsRequestBody EnhanceTransactionsRequestBody) ApiEnhanceTransactionsRequest {
	r.enhanceTransactionsRequestBody = &enhanceTransactionsRequestBody
	return r
}

func (r ApiEnhanceTransactionsRequest) Execute() (*EnhanceTransactionsResponseBody, *http.Response, error) {
	return r.ApiService.EnhanceTransactionsExecute(r)
}

/*
EnhanceTransactions Enhance transactions

Use this endpoint to categorize, cleanse, and classify transactions. These transactions are not persisted or stored on the MX platform. <br /><br />For more information on returned data, please see the [Enhanced Transactions fields guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEnhanceTransactionsRequest
*/
func (a *TransactionsAPIService) EnhanceTransactions(ctx context.Context) ApiEnhanceTransactionsRequest {
	return ApiEnhanceTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EnhanceTransactionsResponseBody
func (a *TransactionsAPIService) EnhanceTransactionsExecute(r ApiEnhanceTransactionsRequest) (*EnhanceTransactionsResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnhanceTransactionsResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.EnhanceTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/enhance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.enhanceTransactionsRequestBody == nil {
		return localVarReturnValue, nil, reportError("enhanceTransactionsRequestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.mx.api.v1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.enhanceTransactionsRequestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtendHistoryRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	memberGuid string
	userGuid string
}

func (r ApiExtendHistoryRequest) Execute() (*MemberResponseBody, *http.Response, error) {
	return r.ApiService.ExtendHistoryExecute(r)
}

/*
ExtendHistory Extend history

Some institutions allow developers to access an extended transaction history with up to 24 months of data associated with a particular member. The process for fetching and then reading this extended transaction history is much like standard aggregation, and it may trigger multi-factor authentication.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param memberGuid The unique id for a `member`.
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiExtendHistoryRequest
*/
func (a *TransactionsAPIService) ExtendHistory(ctx context.Context, memberGuid string, userGuid string) ApiExtendHistoryRequest {
	return ApiExtendHistoryRequest{
		ApiService: a,
		ctx: ctx,
		memberGuid: memberGuid,
		userGuid: userGuid,
	}
}

// Execute executes the request
//  @return MemberResponseBody
func (a *TransactionsAPIService) ExtendHistoryExecute(r ApiExtendHistoryRequest) (*MemberResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MemberResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.ExtendHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/members/{member_guid}/extend_history"
	localVarPath = strings.Replace(localVarPath, "{"+"member_guid"+"}", url.PathEscape(parameterValueToString(r.memberGuid, "memberGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.mx.api.v1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTransactionsRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	userGuid string
	page *int32
	recordsPerPage *int32
	fromDate *string
	toDate *string
	fromCreatedAt *string
	toCreatedAt *string
	fromUpdatedAt *string
	toUpdatedAt *string
	categoryGuid *string
	categoryGuid2 *[]string
	topLevelCategoryGuid *string
	topLevelCategoryGuid2 *[]string
	useCase *string
	includes *string
}

// Results are paginated. Specify current page.
func (r ApiListTransactionsRequest) Page(page int32) ApiListTransactionsRequest {
	r.page = &page
	return r
}

// This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
func (r ApiListTransactionsRequest) RecordsPerPage(recordsPerPage int32) ApiListTransactionsRequest {
	r.recordsPerPage = &recordsPerPage
	return r
}

// Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
func (r ApiListTransactionsRequest) FromDate(fromDate string) ApiListTransactionsRequest {
	r.fromDate = &fromDate
	return r
}

// Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
func (r ApiListTransactionsRequest) ToDate(toDate string) ApiListTransactionsRequest {
	r.toDate = &toDate
	return r
}

// Filter transactions from the date the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
func (r ApiListTransactionsRequest) FromCreatedAt(fromCreatedAt string) ApiListTransactionsRequest {
	r.fromCreatedAt = &fromCreatedAt
	return r
}

// Filter transaction to the date in which the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
func (r ApiListTransactionsRequest) ToCreatedAt(toCreatedAt string) ApiListTransactionsRequest {
	r.toCreatedAt = &toCreatedAt
	return r
}

// Filter transactions from the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
func (r ApiListTransactionsRequest) FromUpdatedAt(fromUpdatedAt string) ApiListTransactionsRequest {
	r.fromUpdatedAt = &fromUpdatedAt
	return r
}

// Filter transactions to the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
func (r ApiListTransactionsRequest) ToUpdatedAt(toUpdatedAt string) ApiListTransactionsRequest {
	r.toUpdatedAt = &toUpdatedAt
	return r
}

// Filter transactions belonging to specified &#x60;category_guid&#x60;.  For example, &#x60;?category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
func (r ApiListTransactionsRequest) CategoryGuid(categoryGuid string) ApiListTransactionsRequest {
	r.categoryGuid = &categoryGuid
	return r
}

// Filter transactions belonging to any specified &#x60;category_guid[]&#x60; in url.  For example, &#x60;?category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
func (r ApiListTransactionsRequest) CategoryGuid2(categoryGuid2 []string) ApiListTransactionsRequest {
	r.categoryGuid2 = &categoryGuid2
	return r
}

// Filter transactions belonging to specified &#x60;top_level_category_guid&#x60;. This must be top level category guid, use &#x60;category_guid&#x60; for subcategory guid.  For example, &#x60;?top_level_category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
func (r ApiListTransactionsRequest) TopLevelCategoryGuid(topLevelCategoryGuid string) ApiListTransactionsRequest {
	r.topLevelCategoryGuid = &topLevelCategoryGuid
	return r
}

// Filter transactions belonging to any specified &#x60;top_level_category_guid[]&#x60; in url. This must be top level category guid(s), use &#x60;category_guid&#x60; for subcategory guid(s).  For example, &#x60;?top_level_category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
func (r ApiListTransactionsRequest) TopLevelCategoryGuid2(topLevelCategoryGuid2 []string) ApiListTransactionsRequest {
	r.topLevelCategoryGuid2 = &topLevelCategoryGuid2
	return r
}

// The use case associated with the member. Valid values are &#x60;PFM&#x60; and &#x60;MONEY_MOVEMENT&#x60;. For example, you can append either &#x60;?use_case&#x3D;PFM&#x60; or &#x60;?use_case&#x3D;MONEY_MOVEMENT&#x60;.
func (r ApiListTransactionsRequest) UseCase(useCase string) ApiListTransactionsRequest {
	r.useCase = &useCase
	return r
}

// Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
func (r ApiListTransactionsRequest) Includes(includes string) ApiListTransactionsRequest {
	r.includes = &includes
	return r
}

func (r ApiListTransactionsRequest) Execute() (*TransactionsResponseBodyIncludes, *http.Response, error) {
	return r.ApiService.ListTransactionsExecute(r)
}

/*
ListTransactions List transactions

Requests to this endpoint return a list of transactions associated with the specified `user`, across all members and accounts associated with that `user`. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiListTransactionsRequest
*/
func (a *TransactionsAPIService) ListTransactions(ctx context.Context, userGuid string) ApiListTransactionsRequest {
	return ApiListTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		userGuid: userGuid,
	}
}

// Execute executes the request
//  @return TransactionsResponseBodyIncludes
func (a *TransactionsAPIService) ListTransactionsExecute(r ApiListTransactionsRequest) (*TransactionsResponseBodyIncludes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionsResponseBodyIncludes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.ListTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.recordsPerPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "records_per_page", r.recordsPerPage, "")
	}
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_date", r.fromDate, "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_date", r.toDate, "")
	}
	if r.fromCreatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_created_at", r.fromCreatedAt, "")
	}
	if r.toCreatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_created_at", r.toCreatedAt, "")
	}
	if r.fromUpdatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_updated_at", r.fromUpdatedAt, "")
	}
	if r.toUpdatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_updated_at", r.toUpdatedAt, "")
	}
	if r.categoryGuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category_guid", r.categoryGuid, "")
	}
	if r.categoryGuid2 != nil {
		t := *r.categoryGuid2
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "category_guid[]", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "category_guid[]", t, "multi")
		}
	}
	if r.topLevelCategoryGuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "top_level_category_guid", r.topLevelCategoryGuid, "")
	}
	if r.topLevelCategoryGuid2 != nil {
		t := *r.topLevelCategoryGuid2
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "top_level_category_guid[]", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "top_level_category_guid[]", t, "multi")
		}
	}
	if r.useCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "use_case", r.useCase, "")
	}
	if r.includes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includes", r.includes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.mx.api.v1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTransactionsByAccountRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	accountGuid string
	userGuid string
	page *int32
	recordsPerPage *int32
	fromDate *string
	toDate *string
	fromCreatedAt *string
	toCreatedAt *string
	fromUpdatedAt *string
	toUpdatedAt *string
	categoryGuid *string
	categoryGuid2 *[]string
	topLevelCategoryGuid *string
	topLevelCategoryGuid2 *[]string
	includes *string
}

// Results are paginated. Specify current page.
func (r ApiListTransactionsByAccountRequest) Page(page int32) ApiListTransactionsByAccountRequest {
	r.page = &page
	return r
}

// This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
func (r ApiListTransactionsByAccountRequest) RecordsPerPage(recordsPerPage int32) ApiListTransactionsByAccountRequest {
	r.recordsPerPage = &recordsPerPage
	return r
}

// Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
func (r ApiListTransactionsByAccountRequest) FromDate(fromDate string) ApiListTransactionsByAccountRequest {
	r.fromDate = &fromDate
	return r
}

// Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
func (r ApiListTransactionsByAccountRequest) ToDate(toDate string) ApiListTransactionsByAccountRequest {
	r.toDate = &toDate
	return r
}

// Filter transactions from the date the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
func (r ApiListTransactionsByAccountRequest) FromCreatedAt(fromCreatedAt string) ApiListTransactionsByAccountRequest {
	r.fromCreatedAt = &fromCreatedAt
	return r
}

// Filter transaction to the date in which the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
func (r ApiListTransactionsByAccountRequest) ToCreatedAt(toCreatedAt string) ApiListTransactionsByAccountRequest {
	r.toCreatedAt = &toCreatedAt
	return r
}

// Filter transactions from the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
func (r ApiListTransactionsByAccountRequest) FromUpdatedAt(fromUpdatedAt string) ApiListTransactionsByAccountRequest {
	r.fromUpdatedAt = &fromUpdatedAt
	return r
}

// Filter transactions to the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
func (r ApiListTransactionsByAccountRequest) ToUpdatedAt(toUpdatedAt string) ApiListTransactionsByAccountRequest {
	r.toUpdatedAt = &toUpdatedAt
	return r
}

// Filter transactions belonging to specified &#x60;category_guid&#x60;.  For example, &#x60;?category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
func (r ApiListTransactionsByAccountRequest) CategoryGuid(categoryGuid string) ApiListTransactionsByAccountRequest {
	r.categoryGuid = &categoryGuid
	return r
}

// Filter transactions belonging to any specified &#x60;category_guid[]&#x60; in url.  For example, &#x60;?category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
func (r ApiListTransactionsByAccountRequest) CategoryGuid2(categoryGuid2 []string) ApiListTransactionsByAccountRequest {
	r.categoryGuid2 = &categoryGuid2
	return r
}

// Filter transactions belonging to specified &#x60;top_level_category_guid&#x60;. This must be top level category guid, use &#x60;category_guid&#x60; for subcategory guid.  For example, &#x60;?top_level_category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
func (r ApiListTransactionsByAccountRequest) TopLevelCategoryGuid(topLevelCategoryGuid string) ApiListTransactionsByAccountRequest {
	r.topLevelCategoryGuid = &topLevelCategoryGuid
	return r
}

// Filter transactions belonging to any specified &#x60;top_level_category_guid[]&#x60; in url. This must be top level category guid(s), use &#x60;category_guid&#x60; for subcategory guid(s).  For example, &#x60;?top_level_category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
func (r ApiListTransactionsByAccountRequest) TopLevelCategoryGuid2(topLevelCategoryGuid2 []string) ApiListTransactionsByAccountRequest {
	r.topLevelCategoryGuid2 = &topLevelCategoryGuid2
	return r
}

// Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
func (r ApiListTransactionsByAccountRequest) Includes(includes string) ApiListTransactionsByAccountRequest {
	r.includes = &includes
	return r
}

func (r ApiListTransactionsByAccountRequest) Execute() (*TransactionsResponseBodyIncludes, *http.Response, error) {
	return r.ApiService.ListTransactionsByAccountExecute(r)
}

/*
ListTransactionsByAccount List transactions by account

Requests to this endpoint return a list of transactions associated with the specified account. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountGuid The unique id for an `account`.
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiListTransactionsByAccountRequest
*/
func (a *TransactionsAPIService) ListTransactionsByAccount(ctx context.Context, accountGuid string, userGuid string) ApiListTransactionsByAccountRequest {
	return ApiListTransactionsByAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountGuid: accountGuid,
		userGuid: userGuid,
	}
}

// Execute executes the request
//  @return TransactionsResponseBodyIncludes
func (a *TransactionsAPIService) ListTransactionsByAccountExecute(r ApiListTransactionsByAccountRequest) (*TransactionsResponseBodyIncludes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionsResponseBodyIncludes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.ListTransactionsByAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/accounts/{account_guid}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"account_guid"+"}", url.PathEscape(parameterValueToString(r.accountGuid, "accountGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.recordsPerPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "records_per_page", r.recordsPerPage, "")
	}
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_date", r.fromDate, "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_date", r.toDate, "")
	}
	if r.fromCreatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_created_at", r.fromCreatedAt, "")
	}
	if r.toCreatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_created_at", r.toCreatedAt, "")
	}
	if r.fromUpdatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_updated_at", r.fromUpdatedAt, "")
	}
	if r.toUpdatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_updated_at", r.toUpdatedAt, "")
	}
	if r.categoryGuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category_guid", r.categoryGuid, "")
	}
	if r.categoryGuid2 != nil {
		t := *r.categoryGuid2
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "category_guid[]", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "category_guid[]", t, "multi")
		}
	}
	if r.topLevelCategoryGuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "top_level_category_guid", r.topLevelCategoryGuid, "")
	}
	if r.topLevelCategoryGuid2 != nil {
		t := *r.topLevelCategoryGuid2
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "top_level_category_guid[]", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "top_level_category_guid[]", t, "multi")
		}
	}
	if r.includes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includes", r.includes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.mx.api.v1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTransactionsByMemberRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	memberGuid string
	userGuid string
	page *int32
	recordsPerPage *int32
	fromDate *string
	toDate *string
	fromCreatedAt *string
	toCreatedAt *string
	fromUpdatedAt *string
	toUpdatedAt *string
	categoryGuid *string
	categoryGuid2 *[]string
	topLevelCategoryGuid *string
	topLevelCategoryGuid2 *[]string
	includes *string
}

// Results are paginated. Specify current page.
func (r ApiListTransactionsByMemberRequest) Page(page int32) ApiListTransactionsByMemberRequest {
	r.page = &page
	return r
}

// This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
func (r ApiListTransactionsByMemberRequest) RecordsPerPage(recordsPerPage int32) ApiListTransactionsByMemberRequest {
	r.recordsPerPage = &recordsPerPage
	return r
}

// Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
func (r ApiListTransactionsByMemberRequest) FromDate(fromDate string) ApiListTransactionsByMemberRequest {
	r.fromDate = &fromDate
	return r
}

// Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
func (r ApiListTransactionsByMemberRequest) ToDate(toDate string) ApiListTransactionsByMemberRequest {
	r.toDate = &toDate
	return r
}

// Filter transactions from the date the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
func (r ApiListTransactionsByMemberRequest) FromCreatedAt(fromCreatedAt string) ApiListTransactionsByMemberRequest {
	r.fromCreatedAt = &fromCreatedAt
	return r
}

// Filter transaction to the date in which the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
func (r ApiListTransactionsByMemberRequest) ToCreatedAt(toCreatedAt string) ApiListTransactionsByMemberRequest {
	r.toCreatedAt = &toCreatedAt
	return r
}

// Filter transactions from the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
func (r ApiListTransactionsByMemberRequest) FromUpdatedAt(fromUpdatedAt string) ApiListTransactionsByMemberRequest {
	r.fromUpdatedAt = &fromUpdatedAt
	return r
}

// Filter transactions to the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
func (r ApiListTransactionsByMemberRequest) ToUpdatedAt(toUpdatedAt string) ApiListTransactionsByMemberRequest {
	r.toUpdatedAt = &toUpdatedAt
	return r
}

// Filter transactions belonging to specified &#x60;category_guid&#x60;.  For example, &#x60;?category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
func (r ApiListTransactionsByMemberRequest) CategoryGuid(categoryGuid string) ApiListTransactionsByMemberRequest {
	r.categoryGuid = &categoryGuid
	return r
}

// Filter transactions belonging to any specified &#x60;category_guid[]&#x60; in url.  For example, &#x60;?category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
func (r ApiListTransactionsByMemberRequest) CategoryGuid2(categoryGuid2 []string) ApiListTransactionsByMemberRequest {
	r.categoryGuid2 = &categoryGuid2
	return r
}

// Filter transactions belonging to specified &#x60;top_level_category_guid&#x60;. This must be top level category guid, use &#x60;category_guid&#x60; for subcategory guid.  For example, &#x60;?top_level_category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
func (r ApiListTransactionsByMemberRequest) TopLevelCategoryGuid(topLevelCategoryGuid string) ApiListTransactionsByMemberRequest {
	r.topLevelCategoryGuid = &topLevelCategoryGuid
	return r
}

// Filter transactions belonging to any specified &#x60;top_level_category_guid[]&#x60; in url. This must be top level category guid(s), use &#x60;category_guid&#x60; for subcategory guid(s).  For example, &#x60;?top_level_category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
func (r ApiListTransactionsByMemberRequest) TopLevelCategoryGuid2(topLevelCategoryGuid2 []string) ApiListTransactionsByMemberRequest {
	r.topLevelCategoryGuid2 = &topLevelCategoryGuid2
	return r
}

// Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
func (r ApiListTransactionsByMemberRequest) Includes(includes string) ApiListTransactionsByMemberRequest {
	r.includes = &includes
	return r
}

func (r ApiListTransactionsByMemberRequest) Execute() (*TransactionsResponseBodyIncludes, *http.Response, error) {
	return r.ApiService.ListTransactionsByMemberExecute(r)
}

/*
ListTransactionsByMember List transactions by member

Requests to this endpoint return a list of transactions associated with the specified `member`, across all accounts associated with that `member`. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param memberGuid The unique id for a `member`.
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiListTransactionsByMemberRequest
*/
func (a *TransactionsAPIService) ListTransactionsByMember(ctx context.Context, memberGuid string, userGuid string) ApiListTransactionsByMemberRequest {
	return ApiListTransactionsByMemberRequest{
		ApiService: a,
		ctx: ctx,
		memberGuid: memberGuid,
		userGuid: userGuid,
	}
}

// Execute executes the request
//  @return TransactionsResponseBodyIncludes
func (a *TransactionsAPIService) ListTransactionsByMemberExecute(r ApiListTransactionsByMemberRequest) (*TransactionsResponseBodyIncludes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionsResponseBodyIncludes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.ListTransactionsByMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/members/{member_guid}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"member_guid"+"}", url.PathEscape(parameterValueToString(r.memberGuid, "memberGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.recordsPerPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "records_per_page", r.recordsPerPage, "")
	}
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_date", r.fromDate, "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_date", r.toDate, "")
	}
	if r.fromCreatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_created_at", r.fromCreatedAt, "")
	}
	if r.toCreatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_created_at", r.toCreatedAt, "")
	}
	if r.fromUpdatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_updated_at", r.fromUpdatedAt, "")
	}
	if r.toUpdatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_updated_at", r.toUpdatedAt, "")
	}
	if r.categoryGuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category_guid", r.categoryGuid, "")
	}
	if r.categoryGuid2 != nil {
		t := *r.categoryGuid2
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "category_guid[]", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "category_guid[]", t, "multi")
		}
	}
	if r.topLevelCategoryGuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "top_level_category_guid", r.topLevelCategoryGuid, "")
	}
	if r.topLevelCategoryGuid2 != nil {
		t := *r.topLevelCategoryGuid2
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "top_level_category_guid[]", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "top_level_category_guid[]", t, "multi")
		}
	}
	if r.includes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includes", r.includes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.mx.api.v1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTransactionsByTagRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	userGuid string
	tagGuid string
	page *int32
	recordsPerPage *int32
	fromDate *string
	toDate *string
	fromCreatedAt *string
	toCreatedAt *string
	fromUpdatedAt *string
	toUpdatedAt *string
	categoryGuid *string
	categoryGuid2 *[]string
	topLevelCategoryGuid *string
	topLevelCategoryGuid2 *[]string
	useCase *string
	includes *string
}

// Results are paginated. Specify current page.
func (r ApiListTransactionsByTagRequest) Page(page int32) ApiListTransactionsByTagRequest {
	r.page = &page
	return r
}

// This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
func (r ApiListTransactionsByTagRequest) RecordsPerPage(recordsPerPage int32) ApiListTransactionsByTagRequest {
	r.recordsPerPage = &recordsPerPage
	return r
}

// Filter transactions from this date. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 120 days ago if not provided.
func (r ApiListTransactionsByTagRequest) FromDate(fromDate string) ApiListTransactionsByTagRequest {
	r.fromDate = &fromDate
	return r
}

// Filter transactions to this date (at midnight). This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Defaults to 5 days forward from the day the request is made to capture pending transactions.
func (r ApiListTransactionsByTagRequest) ToDate(toDate string) ApiListTransactionsByTagRequest {
	r.toDate = &toDate
	return r
}

// Filter transactions from the date the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
func (r ApiListTransactionsByTagRequest) FromCreatedAt(fromCreatedAt string) ApiListTransactionsByTagRequest {
	r.fromCreatedAt = &fromCreatedAt
	return r
}

// Filter transaction to the date in which the transaction was created. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
func (r ApiListTransactionsByTagRequest) ToCreatedAt(toCreatedAt string) ApiListTransactionsByTagRequest {
	r.toCreatedAt = &toCreatedAt
	return r
}

// Filter transactions from the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
func (r ApiListTransactionsByTagRequest) FromUpdatedAt(fromUpdatedAt string) ApiListTransactionsByTagRequest {
	r.fromUpdatedAt = &fromUpdatedAt
	return r
}

// Filter transactions to the date in which the transaction was updated. This only supports ISO 8601 format without timestamp (YYYY-MM-DD). Maximum date range limit is 6 months.
func (r ApiListTransactionsByTagRequest) ToUpdatedAt(toUpdatedAt string) ApiListTransactionsByTagRequest {
	r.toUpdatedAt = &toUpdatedAt
	return r
}

// Filter transactions belonging to specified &#x60;category_guid&#x60;.  For example, &#x60;?category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
func (r ApiListTransactionsByTagRequest) CategoryGuid(categoryGuid string) ApiListTransactionsByTagRequest {
	r.categoryGuid = &categoryGuid
	return r
}

// Filter transactions belonging to any specified &#x60;category_guid[]&#x60; in url.  For example, &#x60;?category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
func (r ApiListTransactionsByTagRequest) CategoryGuid2(categoryGuid2 []string) ApiListTransactionsByTagRequest {
	r.categoryGuid2 = &categoryGuid2
	return r
}

// Filter transactions belonging to specified &#x60;top_level_category_guid&#x60;. This must be top level category guid, use &#x60;category_guid&#x60; for subcategory guid.  For example, &#x60;?top_level_category_guid&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
func (r ApiListTransactionsByTagRequest) TopLevelCategoryGuid(topLevelCategoryGuid string) ApiListTransactionsByTagRequest {
	r.topLevelCategoryGuid = &topLevelCategoryGuid
	return r
}

// Filter transactions belonging to any specified &#x60;top_level_category_guid[]&#x60; in url. This must be top level category guid(s), use &#x60;category_guid&#x60; for subcategory guid(s).  For example, &#x60;?top_level_category_guid[]&#x3D;CAT-7829f71c-2e8c-afa5-2f55-fa3634b89874&#x60;.
func (r ApiListTransactionsByTagRequest) TopLevelCategoryGuid2(topLevelCategoryGuid2 []string) ApiListTransactionsByTagRequest {
	r.topLevelCategoryGuid2 = &topLevelCategoryGuid2
	return r
}

// The use case associated with the member. Valid values are &#x60;PFM&#x60; and &#x60;MONEY_MOVEMENT&#x60;. For example, you can append either &#x60;?use_case&#x3D;PFM&#x60; or &#x60;?use_case&#x3D;MONEY_MOVEMENT&#x60;.
func (r ApiListTransactionsByTagRequest) UseCase(useCase string) ApiListTransactionsByTagRequest {
	r.useCase = &useCase
	return r
}

// Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
func (r ApiListTransactionsByTagRequest) Includes(includes string) ApiListTransactionsByTagRequest {
	r.includes = &includes
	return r
}

func (r ApiListTransactionsByTagRequest) Execute() (*TransactionsResponseBodyIncludes, *http.Response, error) {
	return r.ApiService.ListTransactionsByTagExecute(r)
}

/*
ListTransactionsByTag List transactions by tag

Use this endpoint to get a list of all transactions associated with a particular tag according to the tag's unique GUID. This lists all transactions that have been assigned to a particular tag using the create tagging endpoint. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @param tagGuid The unique id for a `tag`.
 @return ApiListTransactionsByTagRequest
*/
func (a *TransactionsAPIService) ListTransactionsByTag(ctx context.Context, userGuid string, tagGuid string) ApiListTransactionsByTagRequest {
	return ApiListTransactionsByTagRequest{
		ApiService: a,
		ctx: ctx,
		userGuid: userGuid,
		tagGuid: tagGuid,
	}
}

// Execute executes the request
//  @return TransactionsResponseBodyIncludes
func (a *TransactionsAPIService) ListTransactionsByTagExecute(r ApiListTransactionsByTagRequest) (*TransactionsResponseBodyIncludes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionsResponseBodyIncludes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.ListTransactionsByTag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/tags/{tag_guid}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tag_guid"+"}", url.PathEscape(parameterValueToString(r.tagGuid, "tagGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.recordsPerPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "records_per_page", r.recordsPerPage, "")
	}
	if r.fromDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_date", r.fromDate, "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_date", r.toDate, "")
	}
	if r.fromCreatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_created_at", r.fromCreatedAt, "")
	}
	if r.toCreatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_created_at", r.toCreatedAt, "")
	}
	if r.fromUpdatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_updated_at", r.fromUpdatedAt, "")
	}
	if r.toUpdatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_updated_at", r.toUpdatedAt, "")
	}
	if r.categoryGuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category_guid", r.categoryGuid, "")
	}
	if r.categoryGuid2 != nil {
		t := *r.categoryGuid2
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "category_guid[]", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "category_guid[]", t, "multi")
		}
	}
	if r.topLevelCategoryGuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "top_level_category_guid", r.topLevelCategoryGuid, "")
	}
	if r.topLevelCategoryGuid2 != nil {
		t := *r.topLevelCategoryGuid2
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "top_level_category_guid[]", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "top_level_category_guid[]", t, "multi")
		}
	}
	if r.useCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "use_case", r.useCase, "")
	}
	if r.includes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includes", r.includes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.mx.api.v1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadTransactionRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	userGuid string
	transactionGuid string
	includes *string
}

// Options for enhanced transactions. This query parameter is optional. Possible additional metadata: &#x60;repeating_transactions&#x60;, &#x60;merchants&#x60;, &#x60;classifications&#x60;, &#x60;geolocations&#x60;. The query value is format sensitive. To retrieve all available enhancements, append:  &#x60;?includes&#x3D;repeating_transactions,merchants,classifications,geolocations&#x60;.    The query options may be combined to specific enhancements. For example, to request Repeating Transactions and Geolocation data, use:   &#x60;?includes&#x3D;repeating_transactions,geolocations&#x60;.  - Repeating Transactions: Identifies transactions with predictable recurrence patterns (e.g., Bill, Income, Subscription). - Merchants: Enriches transactions with merchant name. - Classifications: Provides more insight into the type of money movement that is occurring on the transaction, whether it be retail or investments. - Geolocation: Provides geographic metadata. 
func (r ApiReadTransactionRequest) Includes(includes string) ApiReadTransactionRequest {
	r.includes = &includes
	return r
}

func (r ApiReadTransactionRequest) Execute() (*TransactionsResponseBodyIncludes, *http.Response, error) {
	return r.ApiService.ReadTransactionExecute(r)
}

/*
ReadTransaction Read transaction

Requests to this endpoint will return the attributes of the specified `transaction`. To read a manual transaction, use the manual transaction guid in the path as the `transactionGuid`. <br /><br />Enhanced transaction data may be requested using the `includes` parameter. To use this optional parameter, the value should include the optional metadata requested such as `repeating_transactions`, `merchants`, `classifications`, `geolocations`. For more information, see the [Optional Enhancement Query Parameter guide](/api-reference/platform-api/reference/transactions-overview#enhanced-transactions#optional-enhancement-query-parameter).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @param transactionGuid The unique id for a `transaction`.
 @return ApiReadTransactionRequest
*/
func (a *TransactionsAPIService) ReadTransaction(ctx context.Context, userGuid string, transactionGuid string) ApiReadTransactionRequest {
	return ApiReadTransactionRequest{
		ApiService: a,
		ctx: ctx,
		userGuid: userGuid,
		transactionGuid: transactionGuid,
	}
}

// Execute executes the request
//  @return TransactionsResponseBodyIncludes
func (a *TransactionsAPIService) ReadTransactionExecute(r ApiReadTransactionRequest) (*TransactionsResponseBodyIncludes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionsResponseBodyIncludes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.ReadTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/transactions/{transaction_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transaction_guid"+"}", url.PathEscape(parameterValueToString(r.transactionGuid, "transactionGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includes", r.includes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.mx.api.v1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepeatingTransactionsRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	userGuid string
}

func (r ApiRepeatingTransactionsRequest) Execute() (*RepeatingTransactionsResponseBody, *http.Response, error) {
	return r.ApiService.RepeatingTransactionsExecute(r)
}

/*
RepeatingTransactions List Repeating Transactions

Retrieve a list of all recurring transactions for a user. <br /><br />For more see the [Repeating Transactions guide](repeating-transactions-overview.mdx).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiRepeatingTransactionsRequest
*/
func (a *TransactionsAPIService) RepeatingTransactions(ctx context.Context, userGuid string) ApiRepeatingTransactionsRequest {
	return ApiRepeatingTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		userGuid: userGuid,
	}
}

// Execute executes the request
//  @return RepeatingTransactionsResponseBody
func (a *TransactionsAPIService) RepeatingTransactionsExecute(r ApiRepeatingTransactionsRequest) (*RepeatingTransactionsResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RepeatingTransactionsResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.RepeatingTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/repeating_transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.mx.api.v1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpecificRepeatingTransactionRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	userGuid string
	repeatingTransactionGuid string
}

func (r ApiSpecificRepeatingTransactionRequest) Execute() (*RepeatingTransactionsResponseBody, *http.Response, error) {
	return r.ApiService.SpecificRepeatingTransactionExecute(r)
}

/*
SpecificRepeatingTransaction Get a Repeating Transaction

Get a Specific Repeating Transaction. <br /><br />List For more see the [Repeating Transactions guide](repeating-transactions-overview.mdx)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @param repeatingTransactionGuid The unique id for a recurring transaction.
 @return ApiSpecificRepeatingTransactionRequest
*/
func (a *TransactionsAPIService) SpecificRepeatingTransaction(ctx context.Context, userGuid string, repeatingTransactionGuid string) ApiSpecificRepeatingTransactionRequest {
	return ApiSpecificRepeatingTransactionRequest{
		ApiService: a,
		ctx: ctx,
		userGuid: userGuid,
		repeatingTransactionGuid: repeatingTransactionGuid,
	}
}

// Execute executes the request
//  @return RepeatingTransactionsResponseBody
func (a *TransactionsAPIService) SpecificRepeatingTransactionExecute(r ApiSpecificRepeatingTransactionRequest) (*RepeatingTransactionsResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RepeatingTransactionsResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.SpecificRepeatingTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/repeating_transactions/{repeating_transaction_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"repeating_transaction_guid"+"}", url.PathEscape(parameterValueToString(r.repeatingTransactionGuid, "repeatingTransactionGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.mx.api.v1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTransactionRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	userGuid string
	transactionGuid string
	transactionUpdateRequestBody *TransactionUpdateRequestBody
}

// Transaction object with the fields to be updated.
func (r ApiUpdateTransactionRequest) TransactionUpdateRequestBody(transactionUpdateRequestBody TransactionUpdateRequestBody) ApiUpdateTransactionRequest {
	r.transactionUpdateRequestBody = &transactionUpdateRequestBody
	return r
}

func (r ApiUpdateTransactionRequest) Execute() (*TransactionResponseBody, *http.Response, error) {
	return r.ApiService.UpdateTransactionExecute(r)
}

/*
UpdateTransaction Update transaction

Use this endpoint to update a specific transaction according to its unique GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @param transactionGuid The unique id for a `transaction`.
 @return ApiUpdateTransactionRequest
*/
func (a *TransactionsAPIService) UpdateTransaction(ctx context.Context, userGuid string, transactionGuid string) ApiUpdateTransactionRequest {
	return ApiUpdateTransactionRequest{
		ApiService: a,
		ctx: ctx,
		userGuid: userGuid,
		transactionGuid: transactionGuid,
	}
}

// Execute executes the request
//  @return TransactionResponseBody
func (a *TransactionsAPIService) UpdateTransactionExecute(r ApiUpdateTransactionRequest) (*TransactionResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.UpdateTransaction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/transactions/{transaction_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transaction_guid"+"}", url.PathEscape(parameterValueToString(r.transactionGuid, "transactionGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transactionUpdateRequestBody == nil {
		return localVarReturnValue, nil, reportError("transactionUpdateRequestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.mx.api.v1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transactionUpdateRequestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTransactionByAccountRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	userGuid string
	memberGuid string
	accountGuid string
	transactionGuid string
	transactionUpdateRequestBody *TransactionUpdateRequestBody
}

// Transaction object to be updated
func (r ApiUpdateTransactionByAccountRequest) TransactionUpdateRequestBody(transactionUpdateRequestBody TransactionUpdateRequestBody) ApiUpdateTransactionByAccountRequest {
	r.transactionUpdateRequestBody = &transactionUpdateRequestBody
	return r
}

func (r ApiUpdateTransactionByAccountRequest) Execute() (*TransactionResponseBody, *http.Response, error) {
	return r.ApiService.UpdateTransactionByAccountExecute(r)
}

/*
UpdateTransactionByAccount Update Transaction by Account

Use this endpoint to update a specific transaction according to its unique GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @param memberGuid The unique id for a `member`.
 @param accountGuid The unique id for an `account`.
 @param transactionGuid The unique id for a `transaction`.
 @return ApiUpdateTransactionByAccountRequest
*/
func (a *TransactionsAPIService) UpdateTransactionByAccount(ctx context.Context, userGuid string, memberGuid string, accountGuid string, transactionGuid string) ApiUpdateTransactionByAccountRequest {
	return ApiUpdateTransactionByAccountRequest{
		ApiService: a,
		ctx: ctx,
		userGuid: userGuid,
		memberGuid: memberGuid,
		accountGuid: accountGuid,
		transactionGuid: transactionGuid,
	}
}

// Execute executes the request
//  @return TransactionResponseBody
func (a *TransactionsAPIService) UpdateTransactionByAccountExecute(r ApiUpdateTransactionByAccountRequest) (*TransactionResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.UpdateTransactionByAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/members/{member_guid}/accounts/{account_guid}/transactions/{transaction_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"member_guid"+"}", url.PathEscape(parameterValueToString(r.memberGuid, "memberGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"account_guid"+"}", url.PathEscape(parameterValueToString(r.accountGuid, "accountGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transaction_guid"+"}", url.PathEscape(parameterValueToString(r.transactionGuid, "transactionGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transactionUpdateRequestBody == nil {
		return localVarReturnValue, nil, reportError("transactionUpdateRequestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transactionUpdateRequestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
