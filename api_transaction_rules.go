/*
MX Platform API

The MX Platform API is a powerful, fully-featured API designed to make aggregating and enhancing financial data easy and reliable. It can seamlessly connect your app or website to tens of thousands of financial institutions.  Just getting started? See our [use case guides](/use-cases/). 

API version: 20111101
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mxplatformgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// TransactionRulesAPIService TransactionRulesAPI service
type TransactionRulesAPIService service

type ApiCreateTransactionRuleRequest struct {
	ctx context.Context
	ApiService *TransactionRulesAPIService
	userGuid string
	transactionRuleCreateRequestBody *TransactionRuleCreateRequestBody
}

// TransactionRule object to be created with optional parameters (description) and required parameters (category_guid and match_description)
func (r ApiCreateTransactionRuleRequest) TransactionRuleCreateRequestBody(transactionRuleCreateRequestBody TransactionRuleCreateRequestBody) ApiCreateTransactionRuleRequest {
	r.transactionRuleCreateRequestBody = &transactionRuleCreateRequestBody
	return r
}

func (r ApiCreateTransactionRuleRequest) Execute() (*TransactionRuleResponseBody, *http.Response, error) {
	return r.ApiService.CreateTransactionRuleExecute(r)
}

/*
CreateTransactionRule Create transaction rule

Use this endpoint to create a new transaction rule. The newly-created `transaction_rule` object will be returned if successful.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiCreateTransactionRuleRequest
*/
func (a *TransactionRulesAPIService) CreateTransactionRule(ctx context.Context, userGuid string) ApiCreateTransactionRuleRequest {
	return ApiCreateTransactionRuleRequest{
		ApiService: a,
		ctx: ctx,
		userGuid: userGuid,
	}
}

// Execute executes the request
//  @return TransactionRuleResponseBody
func (a *TransactionRulesAPIService) CreateTransactionRuleExecute(r ApiCreateTransactionRuleRequest) (*TransactionRuleResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionRuleResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionRulesAPIService.CreateTransactionRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/transaction_rules"
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transactionRuleCreateRequestBody == nil {
		return localVarReturnValue, nil, reportError("transactionRuleCreateRequestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.mx.api.v1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transactionRuleCreateRequestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTransactionRulesRequest struct {
	ctx context.Context
	ApiService *TransactionRulesAPIService
	userGuid string
	page *int32
	recordsPerPage *int32
}

// Results are paginated. Specify current page.
func (r ApiListTransactionRulesRequest) Page(page int32) ApiListTransactionRulesRequest {
	r.page = &page
	return r
}

// This specifies the number of records to be returned on each page. Defaults to &#x60;25&#x60;. The valid range is from &#x60;10&#x60; to &#x60;1000&#x60;. If the value exceeds &#x60;1000&#x60;, the default value of &#x60;25&#x60; will be used instead.
func (r ApiListTransactionRulesRequest) RecordsPerPage(recordsPerPage int32) ApiListTransactionRulesRequest {
	r.recordsPerPage = &recordsPerPage
	return r
}

func (r ApiListTransactionRulesRequest) Execute() (*TransactionRulesResponseBody, *http.Response, error) {
	return r.ApiService.ListTransactionRulesExecute(r)
}

/*
ListTransactionRules List transaction rules

Use this endpoint to read the attributes of all existing transaction rules belonging to the user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiListTransactionRulesRequest
*/
func (a *TransactionRulesAPIService) ListTransactionRules(ctx context.Context, userGuid string) ApiListTransactionRulesRequest {
	return ApiListTransactionRulesRequest{
		ApiService: a,
		ctx: ctx,
		userGuid: userGuid,
	}
}

// Execute executes the request
//  @return TransactionRulesResponseBody
func (a *TransactionRulesAPIService) ListTransactionRulesExecute(r ApiListTransactionRulesRequest) (*TransactionRulesResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionRulesResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionRulesAPIService.ListTransactionRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/transaction_rules"
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.recordsPerPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "records_per_page", r.recordsPerPage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.mx.api.v1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadTransactionRuleRequest struct {
	ctx context.Context
	ApiService *TransactionRulesAPIService
	transactionRuleGuid string
	userGuid string
}

func (r ApiReadTransactionRuleRequest) Execute() (*TransactionRuleResponseBody, *http.Response, error) {
	return r.ApiService.ReadTransactionRuleExecute(r)
}

/*
ReadTransactionRule Read transaction rule

Use this endpoint to read the attributes of an existing transaction rule based on the ruleâ€™s unique GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionRuleGuid The unique id for a `transaction_rule`.
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiReadTransactionRuleRequest
*/
func (a *TransactionRulesAPIService) ReadTransactionRule(ctx context.Context, transactionRuleGuid string, userGuid string) ApiReadTransactionRuleRequest {
	return ApiReadTransactionRuleRequest{
		ApiService: a,
		ctx: ctx,
		transactionRuleGuid: transactionRuleGuid,
		userGuid: userGuid,
	}
}

// Execute executes the request
//  @return TransactionRuleResponseBody
func (a *TransactionRulesAPIService) ReadTransactionRuleExecute(r ApiReadTransactionRuleRequest) (*TransactionRuleResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionRuleResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionRulesAPIService.ReadTransactionRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/transaction_rules/{transaction_rule_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"transaction_rule_guid"+"}", url.PathEscape(parameterValueToString(r.transactionRuleGuid, "transactionRuleGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.mx.api.v1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTransactionRuleRequest struct {
	ctx context.Context
	ApiService *TransactionRulesAPIService
	transactionRuleGuid string
	userGuid string
	transactionRuleUpdateRequestBody *TransactionRuleUpdateRequestBody
}

// TransactionRule object to be updated
func (r ApiUpdateTransactionRuleRequest) TransactionRuleUpdateRequestBody(transactionRuleUpdateRequestBody TransactionRuleUpdateRequestBody) ApiUpdateTransactionRuleRequest {
	r.transactionRuleUpdateRequestBody = &transactionRuleUpdateRequestBody
	return r
}

func (r ApiUpdateTransactionRuleRequest) Execute() (*TransactionRuleResponseBody, *http.Response, error) {
	return r.ApiService.UpdateTransactionRuleExecute(r)
}

/*
UpdateTransactionRule Update transaction rule

Use this endpoint to update the attributes of a specific transaction rule based on its unique GUID. The API will respond with the updated transaction_rule object. Any attributes not provided will be left unchanged.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionRuleGuid The unique id for a `transaction_rule`.
 @param userGuid The unique identifier for a `user`, beginning with the prefix `USR-`.
 @return ApiUpdateTransactionRuleRequest
*/
func (a *TransactionRulesAPIService) UpdateTransactionRule(ctx context.Context, transactionRuleGuid string, userGuid string) ApiUpdateTransactionRuleRequest {
	return ApiUpdateTransactionRuleRequest{
		ApiService: a,
		ctx: ctx,
		transactionRuleGuid: transactionRuleGuid,
		userGuid: userGuid,
	}
}

// Execute executes the request
//  @return TransactionRuleResponseBody
func (a *TransactionRulesAPIService) UpdateTransactionRuleExecute(r ApiUpdateTransactionRuleRequest) (*TransactionRuleResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionRuleResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionRulesAPIService.UpdateTransactionRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_guid}/transaction_rules/{transaction_rule_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"transaction_rule_guid"+"}", url.PathEscape(parameterValueToString(r.transactionRuleGuid, "transactionRuleGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_guid"+"}", url.PathEscape(parameterValueToString(r.userGuid, "userGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transactionRuleUpdateRequestBody == nil {
		return localVarReturnValue, nil, reportError("transactionRuleUpdateRequestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/vnd.mx.api.v1+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transactionRuleUpdateRequestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
